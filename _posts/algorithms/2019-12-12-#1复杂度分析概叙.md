---
layout: post
title: 复杂度分析概述
date: 2019-12-12 15:21:58
description: 复杂度分析是整个算法学习的精髓
share: true
tags:
 - notes
comments: true
toc: false
---

## 复杂度分析

通过统计、监控评估算法执行效率有非常大的局限性：测试结果依赖测试环境，测试结果受数据规模的影响大。所以需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法，即时间、空间复杂度分析方法。

### 复杂度标识方法

大O时间复杂度表示法表示代码执行时间随数据规模增长的变化趋势，也叫作渐进时间复杂度，简称时间复杂度。  

分析原则：

* 只关注循环执行次数最多的一段代码
* 加法法则：总复杂度等于量级最大的那段代码的复杂度
* 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 常见时间复杂度实例分析

复杂度量级（按数量级递增）

|名称 | 大O标识| 量级|
|:------|:-------|:--|
|常量阶|O(1)|多项式量级|
|对数阶|O(logn)|多项式量级|
|线性阶|O(n)|多项式量级|
|线性对数阶|O(nlogn)|多项式量级|
|K次方阶|O(n^k)|多项式量级|
|指数阶|O(2^n)|非多项式量级|
|阶乘阶|O(n!)|非多项式量级|

|First Header | Second Header|
|------------ | -------------|
|Content from cell 1 | Content from cell 2|
|Content in the first column | Content in the second column|

越高阶复杂度的算法，执行效率越低。从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)

#### O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

#### O(logn)、O(nlogn)

>对数阶示例
{:.filename}
{% highlight java %}
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
{% endhighlight %}

计算公式相当于** 2^0\*2^1\*2^2...2^x = n **  
因为对数之间可以相互转化(换底公式)，log_3{n} 就等于 log_3{2} * log_2{n}，所以可以忽略底，再则基于大O标记复杂度可以忽略系数，即O(Cf(n)) = O(f(n))。最终统一表示为O(logn)

#### O(m+n)、O(m*n)

>复杂度由两个数据的规模示例
{:.filename}
{% highlight java %}
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
{% endhighlight %}  
无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。  
针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

### 空间复杂度分析

时间复杂度的全称是*渐进时间复杂度*，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是*渐进空间复杂度*（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

>空间复杂度示例
{:.filename}
{% highlight bash %}
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
{% endhighlight %}  
 第2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。